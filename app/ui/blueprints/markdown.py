
class MarkdownRenderer:
    @staticmethod
    def process_markdown_content(text):
        """
        Hybrid Rendering:
        - Code Blocks (```): Protected, escaped.
        - Tables: Rendered as HTML <table>.
        - Internal Images/Attachments: Preserved (Not escaped).
        - Text: Escaped (Raw Markdown view).
        """
        import html
        import re
        import uuid
        
        # 1. Protect Internal HTML (Images & Attachments)
        # We replace them with unique placeholders so they survive html.escape()
        # Pattern 1: Images <img src="image://db/123" />
        # Pattern 2: Attachments &nbsp;<span...>...</a>&nbsp; based on importer format
        
        # Dictionary to store placeholders
        placeholders = {}
        
        def preserve_match(match):
            token = f"__INTERNAL_HTML_PLACEHOLDER_{uuid.uuid4().hex}__"
            placeholders[token] = match.group(0)
            return token
            
        # Regex for Image
        text = re.sub(r'<img src="image://db/\d+"\s*/>', preserve_match, text)
        
        # Regex for Attachment (Approximate match for the specific format generated by obsidian.py)
        # &nbsp;<span style="font-size: 16px;">ðŸ“Ž</span>&nbsp;<a href="attachment://...</a>&nbsp;
        # We can be a bit looser to match 'attachment://' hrefs if we trust the source.
        # But let's try to match the anchor tag at least.
        text = re.sub(r'<a href="attachment://\d+".*?>.*?</a>', preserve_match, text)
        # Also preserve the span icon if strict match needed?
        # Simpler: <span...ðŸ“Ž</span> handles the icon.
        text = re.sub(r'&nbsp;<span.*?>ðŸ“Ž</span>&nbsp;', preserve_match, text)
        text = re.sub(r'&nbsp;', preserve_match, text) # Warning: this might be too aggressive? 
        # Actually, the entire block is: &nbsp;<span...>ðŸ“Ž</span>&nbsp;<a ...>...</a>&nbsp;
        # Let's match roughly known internal patterns.
        
        # Better approach for attachments: Just preserve <a href="attachment://...">...</a>
        # And <span...>ðŸ“Ž</span>
        text = re.sub(r'<span[^>]*>ðŸ“Ž</span>', preserve_match, text)

        # 2. Protect Code Blocks
        # ... (rest of logic) ...
        parts = re.split(r'(```[\s\S]*?```)', text)
        processed_parts = []
        
        for part in parts:
            if part.startswith("```") and part.endswith("```"):
                # Code Block: Escape everything (including placeholders? No, code should show raw placeholders? 
                # Ideally code block shouldn't contain internal HTML unless user typed it. 
                # If we escape code block, placeholders trigger later restoration? 
                # Restoration happens at END. So if code block has placeholder, it gets restored to HTML.
                # This means if I type <img..> in code block, it renders! 
                # FIX: Verify if match was inside code block before? 
                # Complexity: High.
                # Alternative: Do Code Block Splitting FIRST. Then Protect Internal HTML only in NON-CODE parts.
                processed_parts.append(html.escape(part))
            else:
                # Normal Text (or Internal HTML contexts)
                # PROTECT INTERNAL HTML HERE, NOT GLOBALLY
                
                # Apply placeholders to this part only
                def preserve_match_local(match):
                    token = f"__INTERNAL_HTML_PLACEHOLDER_{uuid.uuid4().hex}__"
                    placeholders[token] = match.group(0)
                    return token
                
                # Patterns
                part = re.sub(r'<img src="image://db/\d+"\s*/>', preserve_match_local, part)
                part = re.sub(r'<a href="attachment://\d+".*?>.*?</a>', preserve_match_local, part)
                part = re.sub(r'<span[^>]*>ðŸ“Ž</span>', preserve_match_local, part)
                # We skip separate &nbsp; handling for simplicity, html.escape handles nbsp? No, keeps &nbsp? 
                # html.escape escapes &, so &nbsp; -> &amp;nbsp;.
                # Revert &amp;nbsp; later?
                part = re.sub(r'&nbsp;', preserve_match_local, part)
                
                # Scan for tables ...
                lines = part.split('\n')
                in_table = False
                table_lines = []
                final_lines = []
                
                for line in lines:
                    stripped = line.strip()
                    # Placeholder-safe check: placeholders shouldn't affect table detection if they don't contain pipes or newlines.
                    # UUIDs are safe.
                    
                    is_table_line = stripped.startswith('|') and (stripped.endswith('|') or len(stripped.split('|')) > 1)
                    
                    if is_table_line:
                        in_table = True
                        table_lines.append(line)
                    else:
                        if in_table:
                             final_lines.append(MarkdownRenderer.render_markdown_table(table_lines))
                             table_lines = []
                             in_table = False
                        
                        final_lines.append(html.escape(line))
                        
                if in_table:
                     final_lines.append(MarkdownRenderer.render_markdown_table(table_lines))
                     
                processed_parts.append('\n'.join(final_lines))
                
        content = "".join(processed_parts)
        content = re.sub(r'(?m)^[-*_]{3,}\s*$', '<hr>', content)
        
        # 3. Restore Placeholders
        for token, original in placeholders.items():
            # If it is an image, wrap in div to force block level (User Request)
            if original.startswith('<img'):
                 replacement = f'<div style="margin: 10px 0;">{original}</div>'
            else:
                 replacement = original
                 
            content = content.replace(token, replacement)
            
        return content

    @staticmethod
    def render_markdown_table(lines):
        """Converts list of markdown table lines to HTML table."""
        if len(lines) < 2:
            import html
            return "\n".join([html.escape(l) for l in lines])
            
        import html
        
        html_out = ['<table border="1" cellspacing="0" cellpadding="5">']
        
        # 1. Header
        header_row = lines[0].strip().strip('|').split('|')
        html_out.append("<thead><tr>")
        for h in header_row:
             html_out.append(f"<th>{html.escape(h.strip())}</th>")
        html_out.append("</tr></thead>")
        
        # 2. Body
        html_out.append("<tbody>")
        
        # Skip separator line (line 1) usually "---|---|---"
        start_idx = 1
        if len(lines) > 1 and '---' in lines[1]:
            start_idx = 2
            
        for i in range(start_idx, len(lines)):
            row = lines[i].strip().strip('|').split('|')
            html_out.append("<tr>")
            for cell in row:
                html_out.append(f"<td>{html.escape(cell.strip())}</td>")
            html_out.append("</tr>")
            
        html_out.append("</tbody></table>")
        return "".join(html_out)
